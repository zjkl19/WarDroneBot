# scripts/paddle_runner.py
"""
åŸºäº PaddleOCR çš„çŠ¶æ€å¾ªç?runnerï¼?  - æˆªå± -> OCR åˆ¤å®šçŠ¶æ€ï¼ˆæŒ?configs/ocr_states_fsm.json5ï¼?  - æŒ‰çŠ¶æ€æ‰§è¡Œç‚¹å‡»ï¼ˆä¸»èœå?å‡†å¤‡/ç»“ç®—/å¼¹çª—ï¼‰ï¼Œcombat å¯æ’­æ”¾å½•åˆ¶å®æˆ–æ”¯æŒè¿ç‚?
ç”¨æ³•ç¤ºä¾‹ï¼ˆåœ¨å·²å®‰è£?paddleocr çš?venv å†…ï¼‰ï¼?  python -m scripts.paddle_runner --serial <adb-serial> --cfg configs/ocr_states_fsm.json5 --det-dir ... --rec-dir ... --cls-dir ...
å‚æ•°ï¼?  --interval   çŠ¶æ€è½®è¯¢é—´éš”ï¼ˆç§’ï¼Œé»˜è®¤ 1.5ï¼?  --dry-run    ä»…æ‰“å°çŠ¶æ€ï¼Œä¸å‘é€ç‚¹å‡?  --combat-macro  combat çŠ¶æ€æ’­æ”¾çš„å½•åˆ¶æ–‡ä»¶ï¼ˆJSONï¼?"""
import argparse
import json5
import time
import subprocess
import json
import logging
import threading

from war_drone.adb_client import AdbClient
from war_drone.paddle_state_detector import PaddleStateDetector


def _pct_to_px(p, wh):
    return int(p[0] * wh[0]), int(p[1] * wh[1])


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--serial", default=None, help="adb åºåˆ—å?)
    ap.add_argument("--cfg", default="configs/ocr_states_fsm.json5")
    ap.add_argument("--det-dir", default=None)
    ap.add_argument("--rec-dir", default=None)
    ap.add_argument("--cls-dir", default=None)
    ap.add_argument("--interval", type=float, default=1.5, help="è½®è¯¢é—´éš”ç§?)
    ap.add_argument("--dry-run", action="store_true", help="åªæ‰“å°çŠ¶æ€ï¼Œä¸ç‚¹å‡?)
    ap.add_argument("--combat-auto", action="store_true", help="combat çŠ¶æ€è‡ªåŠ¨æ‰§è¡Œæ”¯æŒç‚¹å‡?)
    ap.add_argument("--combat-sleep", type=float, default=0.8, help="combat è¿ç»­ç‚¹å‡»é—´éš”ç§?)
    ap.add_argument("--combat-macro", default=None, help="combat çŠ¶æ€æ—¶æ’­æ”¾çš„å½•åˆ¶æ–‡ä»¶ï¼ˆJSONï¼?)
    ap.add_argument("--combat-macro-loops", type=int, default=1, help="combat å®å¾ªç¯æ¬¡æ•?)
    ap.add_argument("--macro-sleep-scale", type=float, default=1.0, help="å®äº‹ä»¶é—´éš”ç¼©æ”¾ç³»æ•?)
    ap.add_argument("--max-combat", type=int, default=0, help="combat çŠ¶æ€æ‰§è¡Œçš„æœ€å¤§æ¬¡æ•°ï¼ˆ0=ä¸é™åˆ¶ï¼ŒæŒ‰è¿›å…¥combatè®¡æ•°ï¼?)
    ap.add_argument("--prestart-macro", action="store_true", help="ç‚¹å‡» ready åå»¶æ—¶æ’­æ”¾å®ï¼Œä¸ç­?OCR åˆ¤å®š combat")
    ap.add_argument("--prestart-delay", type=float, default=1.0, help="ready ç‚¹å‡»åå»¶æ—¶å¤šå°‘ç§’å¯åŠ¨å®?)
    ap.add_argument("--quiet", action="store_true", help="å‡å°‘æ—¥å¿—è¾“å‡ºï¼ˆå‹ä½?paddleocr æ—¥å¿—ï¼?)
    args = ap.parse_args()

    if args.quiet:
        logging.getLogger("ppocr").setLevel(logging.ERROR)
        logging.getLogger("PIL").setLevel(logging.ERROR)
        logging.getLogger().setLevel(logging.WARNING)

    cfg = json5.load(open(args.cfg, "r", encoding="utf-8"))
    coords = cfg.get("coords", {})
    W, H = cfg["screen"]["width"], cfg["screen"]["height"]

    det = PaddleStateDetector(args.cfg, det_dir=args.det_dir, rec_dir=args.rec_dir, cls_dir=args.cls_dir)
    adb = AdbClient(serial=args.serial)

    # æ˜ å°„ï¼šçŠ¶æ€?-> ç›¸å¯¹åæ ‡ï¼ˆå¦‚éœ€è°ƒæ•´å¯æ”¹ä¸?config.coords å†…çš„é”®å€¼ï¼‰
    action_map = {
        "main_menu": (0.868165, 0.866667),
        "ready": (0.868165, 0.866667),
        "settlement": (0.150936, 0.85),
        "weapon": (0.098127, 0.543333),  # æ­¦å™¨ç•Œé¢ç‚¹èœå•è¿”å›?        # å¼¹çª—å…³é—­ï¼šé»˜è®¤ç‚¹å±å¹•å³ä¸Šè§’ï¼Œå¦‚éœ€å‡†ç¡®è¯·æ”¹æˆå…·ä½?ROI æŒ‰é’®
        "free_gift": (0.315356, 0.781667),
        "mission_hard": (0.325468, 0.618333),
        "piggy_full": (0.819101, 0.188333),
        "vip_ad": (0.820225, 0.111667),
        "ad_other": (0.95, 0.08),
    }

    # é¢„åŠ è½?combat å®?    macro_events = []
    if args.combat_macro:
        try:
            data = json.load(open(args.combat_macro, "r", encoding="utf-8"))
            macro_events = data.get("events", [])
            print(f"[INFO] loaded combat macro {args.combat_macro}, events={len(macro_events)}")
        except Exception as e:
            print(f"[WARN] æ— æ³•è¯»å– combat å®?{args.combat_macro}: {e}")
            macro_events = []
    macro_running = False
    macro_thread = None
    macro_stop_event = threading.Event()
    macro_scheduled_ts = None

    def tap_px(x, y, label=None):
        adb.tap(x, y)
        if label:
            print(f"[ACTION] {label} -> tap ({x},{y})")

    def tap_pct(pos, label=None):
        if not pos:
            return
        x, y = _pct_to_px(pos, (W, H))
        tap_px(x, y, label=label)

    def do_swipe_pct(start, end, duration_s=0.3):
        base = [adb.adb]
        if adb.serial:
            base += ["-s", adb.serial]
        x1, y1 = _pct_to_px(start, (W, H))
        x2, y2 = _pct_to_px(end, (W, H))
        dur_ms = int(max(1, duration_s * 1000))
        cmd = base + ["shell", "input", "swipe", str(x1), str(y1), str(x2), str(y2), str(dur_ms)]
        subprocess.check_call(cmd)

    def run_macro(events, loops=1, scale=1.0):
        nonlocal macro_idx, macro_loop, macro_last_ts, macro_running
        if not events or not macro_running:
            return
        now = time.time()
        while macro_idx < len(events):
            ev = events[macro_idx]
            dt = float(ev.get("dt", 0.0)) * scale
            if now - macro_last_ts < dt:
                break
            etype = ev.get("type", "tap")
            if etype == "tap":
                pos = ev["pos"]
                tap_pct(pos, label=f"macro[{macro_loop+1}:{macro_idx+1}]")
            elif etype == "swipe":
                start = ev.get("start"); end = ev.get("end")
                dur_s = float(ev.get("duration", 0.3)) * scale
                if start and end:
                    do_swipe_pct(start, end, dur_s)
                    print(f"[ACTION] macro[{macro_loop+1}:{macro_idx+1}] swipe dur={dur_s:.2f}s")
            macro_last_ts = time.time()
            macro_idx += 1
        if macro_idx >= len(events):
            macro_loop += 1
            if macro_loop >= loops:
                macro_running = False
                macro_idx = 0
                macro_loop = 0
                print("[INFO] combat å®æ’­æ”¾ç»“æ?)
            else:
                macro_idx = 0
                macro_last_ts = time.time()

    print("[INFO] paddle runner å¯åŠ¨ï¼ŒæŒ‰ Ctrl+C é€€å‡?)
    prev_state = None
    combat_count = 0
    try:
        while True:
            img = adb.screencap()
            state, dbg = det.predict(img)
            print(f"[STATE] {state} scores={ {k: round(v,2) for k,v in dbg['scores'].items()} }")

            # ç¦»å¼€ combat æ—¶åœæ­¢å®
            if state != "combat" and macro_running:
                print("[INFO] ç¦»å¼€ combatï¼Œç»ˆæ­¢å®æ’­æ”¾")
                macro_running = False
                macro_idx = 0
                macro_loop = 0

            if args.dry_run:
                prev_state = state
                time.sleep(args.interval)
                continue

            # è‹¥å·²é¢„çº¦å®å¯åŠ¨ä¸”æ—¶é—´åˆ°è¾¾ï¼Œåˆ™å¯åŠ¨
            if macro_scheduled_ts and time.time() >= macro_scheduled_ts and not macro_running and macro_events:
                macro_running = True
                macro_idx = 0
                macro_loop = 0
                macro_last_ts = time.time()
                print(f"[INFO] é¢„å¯åŠ¨å® {args.combat_macro} loops={args.combat_macro_loops}")
                macro_scheduled_ts = None

            pos = action_map.get(state)
            if pos:
                x, y = _pct_to_px(pos, (W, H))
                tap_px(x, y, label=state)
                # ç‚¹å‡» ready åï¼Œå¦‚æœå¯ç”¨ prestart-macroï¼Œåˆ™é¢„çº¦å®?                if state == "ready" and args.prestart_macro and macro_events:
                    macro_scheduled_ts = time.time() + args.prestart_delay
                    print(f"[INFO] å·²é¢„çº¦å®ï¼Œå°†åœ?{args.prestart_delay:.2f}s åå¯åŠ?)
            elif state == "combat":
                if prev_state != "combat":
                    combat_count += 1
                    if args.max_combat and combat_count > args.max_combat:
                        print(f"[INFO] combat æ¬¡æ•° {combat_count} è¶…è¿‡é™åˆ¶ {args.max_combat}ï¼Œç»“æŸå¾ªç?)
                        break
                    # è¿›å…¥ combat æ—¶å¯åŠ¨å®
                    if args.combat_macro and macro_events:
                        macro_running = True
                        macro_idx = 0
                        macro_loop = 0
                        macro_last_ts = time.time()
                        print(f"[INFO] combat æ’­æ”¾å®?{args.combat_macro} loops={args.combat_macro_loops}")
                # è‹¥å¼€å?prestart-macro ä¸”å®å°šæœªå¯åŠ¨ï¼Œå¯ä»¥é€‰æ‹©è·³è¿‡ OCR è§¦å‘
                if args.prestart_macro and macro_events and macro_scheduled_ts:
                    # å·²é¢„çº¦ï¼Œç¡®ä¿è¿è¡Œ
                    if not macro_running:
                        macro_running = True
                        macro_idx = 0
                        macro_loop = 0
                        macro_last_ts = time.time()
                        macro_scheduled_ts = None
                        print(f"[INFO] combat é¢„å¯åŠ¨å® {args.combat_macro} loops={args.combat_macro_loops}")
                if args.combat_macro and macro_events and macro_running:
                    run_macro(macro_events, loops=args.combat_macro_loops, scale=args.macro_sleep_scale)
                elif args.combat_auto:
                    print("[INFO] combat è‡ªåŠ¨æ‰§è¡Œæ”¯æŒç‚¹å‡»")
                    for i in range(1, 7):
                        key = f"support{i}"
                        if key in coords:
                            sx, sy = _pct_to_px(coords[key], (W, H))
                            tap_px(sx, sy, label=f"combat->{key}")
                            time.sleep(args.combat_sleep)
                else:
                    print("[INFO] combat çŠ¶æ€ï¼Œæš‚ä¸è‡ªåŠ¨æ“ä½œ")
            prev_state = state
            time.sleep(args.interval)
    except KeyboardInterrupt:
        print("\n[INFO] ç»“æŸ")


if __name__ == "__main__":
    main()

